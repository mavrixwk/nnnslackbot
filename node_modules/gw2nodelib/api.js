// Scroll down a bit to see public API

var config = {
	baseUrl: 'https://api.guildwars2.com/v2/',
	cacheTime: 1800,
	cacheFile: null,
	debug: true,
	api : {
		quaggans: 'quaggans',
		build: 'build',
		characters: 'characters',
		// events: 'events.json',
		// eventNames: 'event_names.json',
		// mapNames: 'map_names.json',
		// worldNames: 'world_names.json',
		// wvwMatches: 'wvw/matches.json',
		// wvwMatchDetails: 'wvw/match_details.json',
		// wvwObjectiveNames: 'wvw/objective_names.json',
		items: 'items',
		// itemDetails: 'item_details.json',
		recipes: 'recipes',
		// recipeDetails: 'recipe_details.json',
		// guildDetails: 'guild_details.json',
		// build: 'build.json',
		// colors: 'colors.json',
	},
};

// Fully load api into config; allows for per-uri cache times
for (var apiKey in config.api) {
	config.api[apiKey] = {
		uri: config.api[apiKey],
		cacheTime: config.cacheTime,
	};
}

// Set up the cache to work with or without a file; defaults to without
var fs = null;
var cache = function() {
	var container = {};

	return {
		get: function(key) {
			return container[key];
		},

		set: function(key, value) {
			if(config.debug) console.log("Writing cache to file: "+config.cacheFile);
			container[key] = value;
			if (config.cacheFile !== null) {
				fs.writeFile(config.cacheFile, JSON.stringify(container), function(err) {
					if (err) throw err;
				});
			}
		},

		load: function(obj) {
			container = obj;
		},
	};
}();

var Gw2ApiLibException = function(message) {
	this.message = message;
	this.name = 'Gw2ApiLibException';
};

// For easily making HTTP request to API
var request = require('request');

// For converting JS object to URI params
var querystring = require('querystring');

// Invokes callback on requested JSON after it is retrieved via GET/cache; throws Gw2ApiLibException if there are bad arguments or an error accessing API
var apiRequest = function(apiKey, options, callback, bypassCache) {
	// Using argument structure [apiKey, callback]
	if ((typeof callback === 'undefined' || typeof callback === 'boolean') && typeof options === 'function') {
		// Using argument structure [apiKey, callback, bypassCache]
		if (typeof callback === 'boolean' && typeof bypassCache === 'undefined') {
			bypassCache = callback;
		}
		callback = options;
		options = null;
	}
	if (typeof apiKey === 'undefined' || typeof callback === 'undefined' || (typeof options !== 'undefined' && typeof options !== 'object')) {
		throw new Gw2ApiLibException('Bad arguments for apiRequest. Make sure all arguments are valid. Arguments: ' + JSON.stringify(arguments));
	}

	// Time to update and recache
	var cacheKey = apiKey + ((options !== undefined) ? '?' + decodeURIComponent(querystring.stringify(options)) : '');
	//console.log("cacheKey " + cacheKey);
	if (bypassCache || typeof cache.get(cacheKey) === 'undefined' || (new Date()) > cache.get(cacheKey).updateAt) {
		if (config.debug && options) console.log("options are "+decodeURIComponent(querystring.stringify(options)));
		var url = config.baseUrl + config.api[apiKey].uri + ((options !== undefined) ? '?' + decodeURIComponent(querystring.stringify(options)) : '');

		if (config.debug) console.log('Updating cache for API Key: ' + cacheKey + ' from URL: ' + url);

		request(url, function (error, response, body) {
			if (error || response.statusCode !== 200) {
				var msg = ((typeof response !== 'undefined') ? '[Status Code ' + response.statusCode + '] ' : '')
					+ 'There was an error requesting the API (URL ' + url + ')'
					+ ((error !== null) ? ': ' + error : '');
				throw new Gw2ApiLibException(msg);
			}
			//console.log("Response: "+JSON.stringify(response.headers['x-page-total']));
			var headerSet = {
				options : options,
				pageSize : response.headers['x-page-size'],
				pageTotal : response.headers['x-page-total'],
				resultCount : response.headers['x-result-count'],
				resultTotal : response.headers['x-result-total']
			}
			cache.set(cacheKey, {
				headers : headerSet,
				json: JSON.parse(body),
				updateAt: (new Date()).setSeconds((new Date()).getSeconds() + config.api[apiKey].cacheTime),
			});
			callback(cache.get(cacheKey).json, cache.get(cacheKey).headers);
		});
		return;
	}
	// Only runs if already found in cache
	callback(cache.get(cacheKey).json, cache.get(cacheKey).headers);
};

// Return the public API
module.exports = function() {
	var ret = {
		// Returns true if successfully set, false if bad arguments (i.e. file doesn't exist)
		// RL: Will always error with new/empty file. Now loads iff file exists already, and sets if files exists
		loadCacheFromFile: function(file) {
			if (typeof file === 'undefined' || file === false) {
				config.cacheFile === null
			} else {
				if (typeof file !== 'string') {
					return false;
				}
				fs = require('fs');
				config.cacheFile = file;
				if (fs.existsSync(config.cacheFile) && (fs.statSync(config.cacheFile).size > 0)) {
					cache.load(JSON.parse(fs.readFileSync(config.cacheFile, {encoding: 'utf8'})));
				}
				else if(config.debug) console.log("File does not exist, will create on first cache save");
			}
			return true;
		},

		// Returns true if successful, false if bad arguments
		setCacheTime: function(seconds, apiKey) {
			// Using argument structure [seconds]
			if (typeof seconds === 'undefined') {
				seconds = apiKey;
				apiKey = null;
			}
			if (typeof seconds !== 'number') {
				return false;
			}

			// Update default cache time and all api keys using default cache time
			if (apiKey === null) {
				var oldCacheTime = config.cacheTime;
				config.cacheTime = seconds;
				for (var apiKey in config.api) {
					// Only updates cache time if using (old) default cache time
					if (config.api[apiKey].cacheTime === oldCacheTime) {
						config.api[apiKey].cacheTime = config.cacheTime;
					}
				}
				if (config.debug) console.log('setCacheTime successful; config.api: ' + JSON.stringify(config.api));
			} else if (!(apiKey in config.api)) {
				return false;
			} else {
				config.api[apiKey].cacheTime = seconds;
				if (config.debug) console.log('setCacheTime successful; config.api.' + apiKey + ': ' + JSON.stringify(config.api[apiKey]));
			}
			
			return true;
		},

		// Returns true if successful, false if apiKey not found
		resetCacheTime: function(apiKey) {
			if (typeof apiKey === 'undefined') {
				for (var apiKey in config.api) {
					config.api[apiKey].cacheTime = config.cacheTime;
				}
			} else if (!(apiKey in config.api)) {
				return false;
			} else {
				config.api[apiKey].cacheTime = config.cacheTime;
			}
			return true;
		},
	};

	// Allows public access to apiRequest for each apiKey, i.e. this.apiKey(function, [optional] object, [optional] boolean)
	for (var apiKey in config.api) {
		// Returns true if successful, false if bad arguments
		ret[apiKey] = function(apiKey) {
			return function(callback, params, bypassCache) {
				if (typeof callback !== 'function' || (typeof params !== 'undefined' && typeof params !== 'object')) {
					return false;
				}

				apiRequest(apiKey, params, callback, bypassCache);
				return true;
			};
		}(apiKey);
	}
	//Loader helper functions; load pages of max page size for bulk download.
	ret.data = {};
	ret.num = 0,
    ret.total = 0,
    ret.half= function (){
      bot.reply(message,"Hrrrng.");
    },
    ret.done= function (){
      bot.reply(message,"Done.");
    },
    ret.error= function (msg){
      console.log("Error: "+msg);
    },
    ret.load=function (apiKey){
      var _half = ret.half;
      var _done = ret.done;
      var _error = ret.error;
      var _data = [];
      num = 0;
      if(!ret[apiKey]) { _error("no apiKey for "+apiKey); return;}
      var fetchParams = {page:0,page_size:200};
      ret[apiKey](function(jsonList, headers) {
	      _data = _data.concat(jsonList);
//	      console.log("data:"+JSON.stringify(_data));
        //console.log("fetched page "+fetchParams.page+" of "+(headers.pageTotal-1));
        total = headers.pageTotal-1.
        var half_length = Math.ceil((headers.pageTotal-1) / 2);
        console.log("half is "+half_length);
        for(var nextPage=1;nextPage<headers.pageTotal;nextPage++){
            ret[apiKey](function(jsonList, headers) {
              _data = _data.concat(jsonList);	
//		      console.log("Concat: "+Object.keys(_data).length);
	          ret.data[apiKey] = _data;
              //if(num==2)console.log("data:"+JSON.stringify(_data));
              // console.log(headers.options.page);
              num++;
              if(num==half_length) _half();
              if(num==headers.pageTotal-1) _done();
              //console.log("fetched page "+headers.options.page+" of "+(headers.pageTotal-1));
            },{page:nextPage,page_size:200});
        }
      },fetchParams);
    }
	return ret;
}();